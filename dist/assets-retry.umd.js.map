{"version":3,"file":"assets-retry.umd.js","sources":["../src/util.ts","../src/constants.ts","../src/collector.ts","../src/url.ts","../src/retry-sync.ts","../src/assets-retry.ts"],"sourcesContent":["import { scriptTag, linkTag, doc, retryIdentifier, ScriptElementCtor, LinkElementCtor, ImageElementCtor, ElementCtor } from './constants'\n\nexport const identity = function<T>(x: T): T {\n    return x\n}\nexport const noop = () => {\n    /* noop */\n}\n\nexport const hasOwn = Object.prototype.hasOwnProperty\n/**\n * safely calls a function\n *\n * @template T this\n * @template R ReturnType<func>\n * @param {(this: T, ...callbackArgs: any[]) => R} func\n * @param {T} thisArg\n * @param {*} args\n * @returns {R}\n */\nexport const safeCall = function<T, R>(\n    func: (this: T, ...callbackArgs: any[]) => R,\n    thisArg: T,\n    args: any\n): R {\n    // eslint-disable-next-line\n    if (typeof func !== 'function') {\n        return null as any\n    }\n    return func.call(thisArg, args)\n}\n\n/**\n * replace a substring with new one\n *\n * @param {string} current current string\n * @param {string} oldStr substring to replace\n * @param {string} newStr new string\n * @returns\n */\nexport const stringReplace = function(current: string, oldStr: string, newStr: string) {\n    const idx = current.indexOf(oldStr)\n    if (idx === -1) {\n        return current\n    }\n    return current.substring(0, idx) + newStr + current.substring(idx + oldStr.length)\n}\n\n/**\n * convert a camelCase string to a dash-separated string.\n *\n * @param {string} str\n * @returns\n */\nexport const toSlug = function(str: string) {\n    return str.replace(/([a-z])([A-Z])/g, (_, $1, $2) => `${$1}-${$2.toLowerCase()}`)\n}\n\n/**\n * transform an array-like object to array\n *\n * @template T\n * @param {ArrayLike<T>} arrayLike\n * @returns {T[]}\n */\nexport const arrayFrom = function<T>(arrayLike: Iterable<T> | ArrayLike<T>): T[] {\n    return [].slice.call(arrayLike)\n}\n/**\n * collect all property names from current object to its ancestor\n *\n * @param {any} obj\n * @returns\n */\nexport const collectPropertyNames = function(obj: any) {\n    const getProto = Object.getPrototypeOf\n        ? Object.getPrototypeOf\n        : function(x: any) {\n              return x.__proto__\n          }\n    let keys = Object.keys(obj)\n    while (getProto(obj)) {\n        keys = keys.concat(Object.keys(getProto(obj)))\n        obj = getProto(obj)\n    }\n    return keys.filter(key => key !== 'constructor')\n}\n\n/**\n * @example\n * isFunctionProperty(HTMLScriptElement.prototype, 'src); // false\n * isFunctionProperty(HTMLScriptElement.prototype, 'getAttribute'); // true\n * @param {any} proto\n * @param {string} key\n * @returns\n */\nexport const isFunctionProperty = function(proto: any, key: string) {\n    try {\n        return typeof proto[key] === 'function'\n    } catch (e) {\n        // TypeError: Illegal invocation\n        // when evaluating properties like\n        // HTMLScriptElement.prototype.src\n        return false\n    }\n}\n\n/**\n * on some browsers, calling `document.write` when\n * `document.readyState` is `loading` will clear the whole\n * page, which is not what we wanted.\n *\n * @returns\n */\nexport const supportDocumentWrite = () => {\n    return !/Edge|MSIE|rv:/i.test(navigator.userAgent)\n}\n\n/**\n * loads a new script element by previous failed script element\n *\n * @param {HTMLScriptElement} $script previous script element\n * @param {string} newSrc new url to try\n */\nexport const loadNextScript = function(\n    $script: HTMLScriptElement,\n    newSrc: string,\n    onload: () => void = noop,\n    isAsync = false\n) {\n    // when dealing with failed script tags in html,\n    // use `document.write` to ensure the correctness\n    // of loading order\n    const isAsyncScript = isAsync || $script.defer || $script.async;\n    // only use document.write for non-async scripts,\n    // which includes script tag created by document.createElement\n    // or with `defer` or `async` attribute\n    if (doc.readyState === 'loading' && supportDocumentWrite() && !isAsyncScript) {\n        const retryId = randomString()\n        const newHtml = $script.outerHTML\n            // delete previous retry id\n            .replace(/data-retry-id=\"[^\"]+\"/, '')\n            .replace(/src=(?:\"[^\"]+\"|.+)([ >])/, `${retryIdentifier}=${retryId} src=\"${newSrc}\"$1`)\n        doc.write(newHtml)\n        const newScript = doc.querySelector(\n            `script[${retryIdentifier}=\"${retryId}\"]`\n        ) as HTMLScriptElement\n        if (newScript) {\n            newScript.onload = onload\n        }\n        return\n    }\n    const $newScript = doc.createElement(scriptTag)\n    // copy script properties except src:\n    // type, noModule, charset, async, defer,\n    // crossOrigin, text, referrerPolicy, event,\n    // htmlFor, integrity (chrome)\n    Object.keys(ScriptElementCtor.prototype).forEach(function(key: string) {\n        if (key !== 'src' && ($script as any)[key] && typeof ($script as any)[key] !== 'object') {\n            try {\n                ;($newScript as any)[key] = ($script as any)[key]\n            } catch (_) {\n                /* noop */\n            }\n        }\n    })\n    $newScript.src = newSrc\n    $newScript.onload = $script.onload\n    $newScript.onerror = $script.onerror\n    $newScript.setAttribute(retryIdentifier, randomString())\n    // webpack nonce for csp\n    const originalNonce = $script.getAttribute('nonce')\n    if (originalNonce) {\n        $newScript.setAttribute('nonce', originalNonce)\n    }\n    doc.getElementsByTagName('head')[0].appendChild($newScript)\n}\n\n/**\n * get rules from styleSheet\n *\n * @param {CSSStyleSheet} styleSheet\n * @returns\n */\nexport const getCssRules = function(styleSheet: CSSStyleSheet) {\n    try {\n        return styleSheet.rules\n    } catch (_) {\n        try {\n            return styleSheet.cssRules\n        } catch (_) {\n            return null\n        }\n    }\n}\n/**\n * test if current browser support CSSRuleList\n *\n * @param {CSSStyleSheet} styleSheet\n * @returns\n */\nexport const supportRules = function(styleSheet: CSSStyleSheet) {\n    const rules = getCssRules(styleSheet)\n    return !!rules\n}\n\n/**\n * loads a new link element by previous failed link element\n *\n * @param {HTMLLinkElement} $link previous link element\n * @param {string} newHref new url to try\n */\nexport const loadNextLink = function($link: HTMLLinkElement, newHref: string, onload: () => void) {\n    const $newLink = doc.createElement(linkTag)\n    // copy link properties except href:\n    // disabled, href, crossOrigin, rel, relList, media, hreflang,\n    // type, as, referrerPolicy, sizes, imageSrcset, imageSizes,\n    // charset, rev, target, sheet, integrity, import (chrome)\n    Object.keys(LinkElementCtor.prototype).forEach(function(key: string) {\n        if (key !== 'href' && ($link as any)[key] && typeof ($link as any)[key] !== 'object') {\n            try {\n                ;($newLink as any)[key] = ($link as any)[key]\n            } catch (_) {\n                /* noop */\n            }\n        }\n    })\n    $newLink.href = newHref\n    $newLink.onload = onload\n    $newLink.setAttribute(retryIdentifier, randomString())\n    doc.getElementsByTagName('head')[0].appendChild($newLink)\n}\n\nexport const hashTarget = function(element: EventTarget | null) {\n    if (!element) {\n        return 'null'\n    }\n    if (!(element instanceof ElementCtor)) {\n        return 'not_supported'\n    }\n    const nodeName = element.nodeName\n    const src = (element as any).src\n    const href = (element as any).href\n    const dataRetryId = element.getAttribute(retryIdentifier)\n    return [nodeName, src, href, dataRetryId].join(';')\n}\n\nexport const randomString = () =>\n    Math.random()\n        .toString(36)\n        .slice(2)\n\n/**\n * 获取 HTML 标签中包含的 URL 信息\n * @param target\n */\nexport const getTargetUrl = function(target: EventTarget | null) {\n    if (target instanceof ScriptElementCtor || target instanceof ImageElementCtor) {\n        return target.src\n    }\n    if (target instanceof LinkElementCtor) {\n        return target.href\n    }\n    return null\n}\n","export const retryTimesProp = 'retryTimes'\nexport const succeededProp = 'succeeded'\nexport const failedProp = 'failed'\nexport const maxRetryCountProp = 'maxRetryCount'\nexport const onRetryProp = 'onRetry'\nexport const onSuccessProp = 'onSuccess'\nexport const onFailProp = 'onFail'\nexport const domainProp = 'domain'\nexport const innerScriptProp = '_assetsRetryScript'\nexport const innerOnloadProp = '_assetsRetryOnload'\nexport const innerOnerrorProp = '_assetsRetryOnerror'\nexport const scriptTag = 'script'\nexport const linkTag = 'link'\nexport const hookedIdentifier = 'data-assets-retry-hooked'\nexport const ignoreIdentifier = 'data-assets-retry-ignore'\nexport const retryIdentifier = 'data-retry-id'\nexport const win = window\nexport const doc = window.document\nexport const ElementCtor = win.HTMLElement\nexport const ScriptElementCtor = win.HTMLScriptElement\nexport const StyleElementCtor = win.HTMLStyleElement\nexport const LinkElementCtor = win.HTMLLinkElement\nexport const ImageElementCtor = win.HTMLImageElement","/** @description data collector */\n\nimport { retryTimesProp, succeededProp, failedProp } from './constants'\n\nexport interface RetryCollector {\n    [x: string]: RetryStatistics\n}\n\nexport interface RetryStatistics {\n    [retryTimesProp]: number\n    [succeededProp]: string[]\n    [failedProp]: string[]\n}\n\n// statistic collector\nexport const retryCollector: RetryCollector = {}\n","import { retryCollector, RetryStatistics } from './collector'\nimport { retryTimesProp, failedProp, succeededProp } from './constants'\n\nexport type Domain =  { [x: string]: string }\nexport interface DomainMap {\n    [x: string]: string\n}\n\n/**\n * get path from src\n * @example\n * getUrlPath('https://a.cdn/js/1.js', 'a.cdn'); // '/js/1.js'\n * getUrlPath('https://a.cdn/namespace/js/1.js', 'a.cdn/namespace'); // '/js/1.js'\n * @param {string} src script src\n * @param {string} currentDomain domain name\n * @returns {string}\n */\nexport const getUrlPath = function(src: string, currentDomain: string) {\n    return src.substr(src.indexOf(currentDomain) + currentDomain.length, src.length)\n}\n\n/**\n * find out the domain of current loading script\n *\n * @param {string} src\n * @param {{ [x: string]: string }} domainMap\n * @returns\n */\nexport const getCurrentDomain = function(src: string, domainMap: DomainMap) {\n    return (\n        Object.keys(domainMap)\n            .filter(function(domain) {\n                return src.indexOf(domain) > -1\n            })\n            // sort by length (relevance)\n            .sort((prev, next) => next.length - prev.length)[0]\n    )\n}\n\n/**\n * extract domain from url, and get the\n * corresponding statistic collector\n * @param {string} url\n * @returns\n */\nexport const extractInfoFromUrl = function(\n    url: string,\n    domainMap: DomainMap\n): [string?, RetryStatistics?] {\n    const [srcPath, currentDomain] = splitUrl(url, domainMap)\n    if (!srcPath) {\n        return []\n    }\n    retryCollector[srcPath] = retryCollector[srcPath] || {\n        [retryTimesProp]: 0,\n        [failedProp]: [],\n        [succeededProp]: []\n    }\n    return [currentDomain, retryCollector[srcPath]]\n}\n\nexport const splitUrl = function(url: string, domainMap: DomainMap): [string, string] {\n    const currentDomain = getCurrentDomain(url, domainMap)\n    if (!currentDomain) {\n        return [url, '']\n    }\n    const srcPath = getUrlPath(url, currentDomain)\n    return [srcPath, currentDomain]\n}\n","import { getTargetUrl, hashTarget, loadNextScript, stringReplace } from './util'\nimport { InnerAssetsRetryOptions } from './assets-retry'\nimport { extractInfoFromUrl, splitUrl } from './url'\nimport {\n    doc,\n    domainProp,\n    failedProp,\n    hookedIdentifier,\n    ignoreIdentifier,\n    maxRetryCountProp,\n    onFailProp,\n    onRetryProp,\n    retryTimesProp,\n    ScriptElementCtor,\n    succeededProp\n} from './constants'\n\nconst retryCache: { [x: string]: boolean } = {}\n\n/**\n * init synchronous retrying of assets,\n * this includes the retrying of\n * script, link and img tags\n *\n * @export\n * @param {InnerAssetsRetryOptions} opts\n */\nexport default function initSync(opts: InnerAssetsRetryOptions) {\n    const onRetry = opts[onRetryProp]\n    const onFail = opts[onFailProp]\n    const domainMap = opts[domainProp]\n    /**\n     * capture error on window\n     * when js failed to load\n     * reload the target with new domain\n     *\n     * @param {ErrorEvent} event\n     * @returns\n     */\n    const errorHandler = function(event: Event) {\n        if (!event) {\n            return\n        }\n        const target = event.target || event.srcElement\n        const originalUrl = getTargetUrl(target)\n        if (!originalUrl) {\n            // not one of script / link / image element\n            return\n        }\n        const [currentDomain, currentCollector] = extractInfoFromUrl(originalUrl, domainMap)\n        const hasIgnoreIdentifier = target instanceof HTMLElement && target.hasAttribute(ignoreIdentifier)\n        if (!currentCollector || !currentDomain || hasIgnoreIdentifier) {\n            return\n        }\n        currentCollector[retryTimesProp]++\n        currentCollector[failedProp].push(originalUrl)\n        const isFinalRetry = currentCollector[retryTimesProp] > opts[maxRetryCountProp]\n        if (isFinalRetry) {\n            const [srcPath] = splitUrl(originalUrl, domainMap)\n            onFail && onFail(srcPath)\n        }\n        if (!domainMap[currentDomain] || isFinalRetry) {\n            // can not find a domain to switch\n            // or failed too many times\n            return\n        }\n        const newDomain = domainMap[currentDomain]\n        const newUrl = stringReplace(originalUrl, currentDomain, newDomain)\n        const userModifiedUrl = onRetry(newUrl, originalUrl, currentCollector)\n        // if onRetry returns null, do not retry this url\n        if (userModifiedUrl === null) {\n            return\n        }\n        // eslint-disable-next-line\n        if (typeof userModifiedUrl !== 'string') {\n            throw new Error('a string should be returned in `onRetry` function')\n        }\n        // cache retried elements\n        const elementId = hashTarget(target)\n        if (retryCache[elementId]) {\n            return\n        }\n        retryCache[elementId] = true\n        const onloadCallback = () => {\n            currentCollector[succeededProp].push(userModifiedUrl)\n        }\n        if (\n            target instanceof ScriptElementCtor &&\n            !target.getAttribute(hookedIdentifier) &&\n            target.src\n        ) {\n            loadNextScript(target, userModifiedUrl, onloadCallback)\n            return\n        }\n    }\n\n    doc.addEventListener('error', errorHandler, true)\n}\n","import initSync from './retry-sync'\nimport { retryCollector, RetryStatistics } from './collector'\nimport { domainProp, maxRetryCountProp, onFailProp, onRetryProp, win } from './constants'\nimport { Domain, DomainMap } from './url'\nimport { identity } from './util'\n\nexport type RetryFunction = (\n    currentUrl: string,\n    originalUrl: string,\n    retryCollector: null | RetryStatistics\n) => string | null\nexport type SuccessFunction = (currentPath: string) => void\nexport type FailFunction = (currentPath: string) => void\n\nexport interface AssetsRetryOptions {\n    [maxRetryCountProp]: number\n    [onRetryProp]?: RetryFunction\n    [onFailProp]?: FailFunction\n    [domainProp]: Domain\n}\n\nexport interface InnerAssetsRetryOptions {\n    [maxRetryCountProp]: number\n    [onRetryProp]: RetryFunction\n    [onFailProp]?: FailFunction\n    [domainProp]: DomainMap\n}\n\nexport default function init(opts: AssetsRetryOptions = {} as any) {\n    try {\n        // eslint-disable-next-line\n        if (typeof opts[domainProp] !== 'object') {\n            throw new Error('opts.domain cannot be non-object.')\n        }\n        const innerOpts: InnerAssetsRetryOptions = {\n            [maxRetryCountProp]: opts[maxRetryCountProp] || 3,\n            [onRetryProp]: opts[onRetryProp] || identity,\n            [onFailProp]: opts[onFailProp],\n            [domainProp]: opts[domainProp]\n        }\n        initSync(innerOpts)\n        return retryCollector\n    } catch (e) {\n        win.console && console.error('[assetsRetry] error captured', e)\n    }\n}\n"],"names":["identity","x","noop","retryTimesProp","succeededProp","failedProp","maxRetryCountProp","onRetryProp","onFailProp","domainProp","hookedIdentifier","ignoreIdentifier","retryIdentifier","win","window","doc","document","ElementCtor","HTMLElement","ScriptElementCtor","HTMLScriptElement","LinkElementCtor","HTMLLinkElement","ImageElementCtor","HTMLImageElement","stringReplace","current","oldStr","newStr","idx","indexOf","substring","length","loadNextScript","$script","newSrc","onload","isAsync","$newScript","originalNonce","retryId","newHtml","newScript","isAsyncScript","defer","async","readyState","test","navigator","userAgent","createElement","Object","keys","prototype","forEach","key","_","src","onerror","setAttribute","randomString","getAttribute","getElementsByTagName","appendChild","outerHTML","replace","write","querySelector","hashTarget","element","nodeName","href","join","Math","random","toString","slice","getTargetUrl","target","retryCollector","extractInfoFromUrl","url","domainMap","_b","splitUrl","srcPath","currentDomain","_a","filter","domain","sort","prev","next","substr","retryCache","opts","onRetry","onFail","Error","innerOpts","addEventListener","event","srcElement","originalUrl","currentCollector","hasIgnoreIdentifier","hasAttribute","push","isFinalRetry","newDomain","newUrl","userModifiedUrl","elementId","e","console","error"],"mappings":"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"}